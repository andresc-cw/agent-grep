#!/usr/bin/env bash
set -euo pipefail

# sg - search Claude Code & Codex sessions, pick one with fzf, resume it
#
# Usage:
#   sg                         Browse all sessions, type to search content
#   sg <search terms>         Search sessions and pick one to resume
#   sg --list                 Browse all sessions, type to search content
#   sg --repo <repo> [terms]  Filter sessions by repo/project + optional content query
#   sg --update [search terms] Re-index sessions before searching

SESSION_DIR="$HOME/.cache/agent-grep/sessions"
FTS_DB="$HOME/.cache/agent-grep/sessions.sqlite"
# Resolve symlinks so SCRIPT_DIR points to the repo, not the symlink location
SELF="$0"
[[ -L "$SELF" ]] && SELF="$(readlink "$SELF")"
SCRIPT_DIR="$(cd "$(dirname "$SELF")" && pwd)"

# -- Search helper -------------------------------------------------------
#
# Written to a temp file so fzf's change:reload can call it.
# Uses sqlite FTS5 for ranked search when available, with rg fallback.
# gawk is required (macOS /usr/bin/awk lacks ENDFILE): brew install gawk

AWK_FMT="$SCRIPT_DIR/.sg_fmt.awk"

usage() {
    cat <<'EOF'
sg - Search and resume Claude Code and Codex sessions.

Usage:
  sg
  sg <search terms>
  sg --list
  sg --repo <repo> [search terms]
  sg --list --repo <repo>
  sg --sort-date [search terms]
  sg --update [search terms]
  sg --help

What it does:
  - Reads a local index of session transcripts in ~/.cache/agent-grep/sessions
  - Opens an interactive picker for searching and previewing sessions
  - Resumes the selected session with claude --resume or codex resume

Notes:
  - Running sg with no arguments opens browse mode (same as --list)
  - If no index exists, sg can prompt to run indexing for you
  - In the picker, press Alt-d to toggle date sorting on/off

Examples:
  sg "billing timeout"
  sg --list
  sg --repo billing
  sg --repo billing "retry policy"
  sg --sort-date --list
  sg --update
  sg --update "auth bug"

Dependencies:
  rg, gawk, fzf (jq for --update; sqlite3 recommended for ranked search)
EOF
}

die() {
    echo "sg: $*" >&2
    exit 1
}

check_dependencies() {
    local missing=()
    local cmd
    for cmd in rg gawk fzf; do
        command -v "$cmd" >/dev/null 2>&1 || missing+=("$cmd")
    done

    if [[ ${#missing[@]} -gt 0 ]]; then
        die "missing dependencies: ${missing[*]} (install with: brew install ripgrep gawk fzf)"
    fi
}

ensure_index() {
    if compgen -G "$SESSION_DIR/*.md" > /dev/null; then
        return 0
    fi

    echo "No indexed sessions found."

    # Prompt only when attached to a TTY; otherwise keep the current non-interactive behavior.
    if [[ ! -t 0 || ! -t 1 ]]; then
        echo "Run: sg --update"
        return 1
    fi

    printf "Run session indexing now? [Y/n] "
    local answer
    if ! IFS= read -r answer; then
        answer="n"
    fi

    case "$answer" in
        ""|[Yy]|[Yy][Ee][Ss])
            command -v jq >/dev/null 2>&1 || die "indexing requires jq (install with: brew install jq)"
            "$SCRIPT_DIR/session2md.sh"
            ;;
        *)
            echo "Run: sg --update"
            return 1
            ;;
    esac

    if ! compgen -G "$SESSION_DIR/*.md" > /dev/null; then
        echo "No sessions were indexed."
        echo "Run: sg --update --full"
        return 1
    fi
}

[[ -f "$AWK_FMT" ]] || die "formatter not found: $AWK_FMT"

HELPER=$(mktemp "${TMPDIR:-/tmp}/sg-helper.XXXXX")
SORT_STATE=""
cleanup() {
    rm -f "$HELPER"
    [[ -n "$SORT_STATE" ]] && rm -f "$SORT_STATE"
}
trap cleanup EXIT INT TERM

cat > "$HELPER" << 'HELPEREOF'
#!/usr/bin/env bash
set -euo pipefail

SESSION_DIR="${SG_SESSION_DIR:?missing SG_SESSION_DIR}"
AWK_FMT="${SG_AWK_FMT:?missing SG_AWK_FMT}"
FTS_DB="${SG_FTS_DB:-}"
REPO_FILTER="${SG_REPO_FILTER:-}"
SORT_STATE_FILE="${SG_SORT_STATE:-}"
SCORE_MAP_FILE=""

cleanup_score_map() {
    [[ -n "$SCORE_MAP_FILE" && -f "$SCORE_MAP_FILE" ]] && rm -f "$SCORE_MAP_FILE"
}
trap cleanup_score_map EXIT

sql_quote() {
    printf "%s" "$1" | sed "s/'/''/g"
}

to_fts_query() {
    local input="$1" token=""
    local parts=()

    while IFS= read -r token; do
        [[ -z "$token" ]] && continue
        parts+=("\"$token\"*")
    done < <(printf '%s' "$input" | tr '[:upper:]' '[:lower:]' | tr -cs '[:alnum:]_-' '\n')

    [[ ${#parts[@]} -eq 0 ]] && return 0

    local query=""
    local term
    for term in "${parts[@]}"; do
        if [[ -z "$query" ]]; then
            query="$term"
        else
            query="$query AND $term"
        fi
    done
    printf '%s\n' "$query"
}

search_ranked_paths() {
    local raw_query="$1" fts_query q_fts sql
    local repo_clause="" q_repo=""

    fts_query=$(to_fts_query "$raw_query")
    [[ -z "$fts_query" ]] && return 0

    q_fts=$(sql_quote "$fts_query")
    if [[ -n "$REPO_FILTER" ]]; then
        q_repo=$(sql_quote "$(printf '%s' "$REPO_FILTER" | tr '[:upper:]' '[:lower:]')")
        repo_clause="AND (instr(lower(project), '$q_repo') > 0 OR instr(lower(project_name), '$q_repo') > 0)"
    fi

    sql=$(cat <<SQL
SELECT path, bm25(sessions_fts, 8.0, 4.0, 1.0) AS raw_score
FROM sessions_fts
WHERE sessions_fts MATCH '$q_fts'
$repo_clause
ORDER BY raw_score, date DESC
LIMIT 400;
SQL
)

    sqlite3 -noheader -separator $'\t' "$FTS_DB" "$sql" 2>/dev/null || true
}

search_fallback_paths() {
    local raw_query="$1"

    rg -i -H --count-matches --no-messages -- "$raw_query" "$SESSION_DIR"/*.md 2>/dev/null \
        | gawk -F: '
            {
                path = $0
                sub(/:[0-9]+$/, "", path)
                count = $0
                sub(/^.*:/, "", count)
                if ((count + 0) > 0) print path "\t" count
            }
        ' \
        | sort -t $'\t' -k2,2nr -k1,1
}

normalize_scores() {
    local mode="$1"
    gawk -F $'\t' -v mode="$mode" '
        NF >= 1 {
            path = $1
            if (path == "") next

            raw = 0.0
            if (NF >= 2 && $2 != "") raw = $2 + 0.0

            paths[++n] = path
            vals[n] = raw
            if (n == 1 || raw < min) min = raw
            if (n == 1 || raw > max) max = raw
        }
        END {
            for (i = 1; i <= n; i++) {
                if (max == min) score = 100
                else if (mode == "lower_better") score = 1 + ((max - vals[i]) / (max - min)) * 99
                else score = 1 + ((vals[i] - min) / (max - min)) * 99

                if (score < 1) score = 1
                if (score > 100) score = 100
                printf "%s\t%.0f\n", paths[i], score
            }
        }
    '
}

append_scores_to_rows() {
    local score_file="$1"
    gawk -F $'\t' -v OFS=$'\t' -v score_file="$score_file" '
        BEGIN {
            while ((getline line < score_file) > 0) {
                split(line, parts, "\t")
                if (parts[1] != "" && parts[2] != "") score[parts[1]] = parts[2]
            }
            close(score_file)
        }
        {
            score_txt = "n/a"
            if ($6 in score) score_txt = sprintf("%3s/100", score[$6])
            $7 = sprintf("[score:%s] %s", score_txt, $7)
            print
        }
    '
}

format_rows_for_matches() {
    local matches="$1"
    local files=()
    local path

    while IFS=$'\t' read -r path _; do
        [[ -z "$path" ]] && continue
        files+=("$path")
    done < <(printf '%s\n' "$matches")

    [[ ${#files[@]} -eq 0 ]] && return 0
    gawk -f "$AWK_FMT" "${files[@]}" 2>/dev/null || true
}

if [[ "${1-}" == "--toggle-sort" ]]; then
    if [[ -z "$SORT_STATE_FILE" ]]; then
        exit 0
    fi
    current="default"
    if [[ -f "$SORT_STATE_FILE" ]]; then
        current=$(cat "$SORT_STATE_FILE" 2>/dev/null || echo "default")
    fi
    if [[ "$current" == "date" ]]; then
        printf "default\n" > "$SORT_STATE_FILE"
    else
        printf "date\n" > "$SORT_STATE_FILE"
    fi
    exit 0
fi

QUERY="${1-}"
if [[ -z "$QUERY" ]]; then
    rows=$(gawk -f "$AWK_FMT" "$SESSION_DIR"/*.md 2>/dev/null || true)
else
    matches=""
    score_mode=""
    if [[ -n "$FTS_DB" && -f "$FTS_DB" ]] && command -v sqlite3 >/dev/null 2>&1; then
        matches=$(search_ranked_paths "$QUERY")
        [[ -n "$matches" ]] && score_mode="lower_better"
    fi
    if [[ -z "$matches" ]]; then
        matches=$(search_fallback_paths "$QUERY" || true)
        [[ -n "$matches" ]] && score_mode="higher_better"
    fi
    if [[ -n "$matches" ]]; then
        rows=$(format_rows_for_matches "$matches")
        if [[ -n "$rows" ]]; then
            SCORE_MAP_FILE=$(mktemp "${TMPDIR:-/tmp}/sg-score.XXXXX")
            printf '%s\n' "$matches" | normalize_scores "$score_mode" > "$SCORE_MAP_FILE"
            rows=$(printf '%s\n' "$rows" | append_scores_to_rows "$SCORE_MAP_FILE")
        fi
    else
        rows=""
    fi
fi

[[ -z "$rows" ]] && exit 0

if [[ -n "$REPO_FILTER" ]]; then
    rows=$(printf '%s\n' "$rows" | gawk -F $'\t' -v repo="$REPO_FILTER" '
        BEGIN { needle = tolower(repo) }
        {
            if (index(tolower($3), needle) || index(tolower($4), needle)) print
        }
    ')
fi

[[ -z "$rows" ]] && exit 0

sort_mode="default"
if [[ -n "$SORT_STATE_FILE" && -f "$SORT_STATE_FILE" ]]; then
    sort_mode=$(cat "$SORT_STATE_FILE" 2>/dev/null || echo "default")
fi

if [[ "$sort_mode" == "date" ]]; then
    printf '%s\n' "$rows" | sort -t $'\t' -k5,5r -k1,1
else
    printf '%s\n' "$rows"
fi
HELPEREOF
chmod +x "$HELPER"

# -- Handle flags --------------------------------------------------------

DO_UPDATE=0
LIST_MODE=0
REPO_FILTER=""
SORT_MODE="default"
QUERY_ARGS=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        --help|-h)
            usage
            exit 0
            ;;
        --update)
            DO_UPDATE=1
            shift
            ;;
        --list)
            LIST_MODE=1
            shift
            ;;
        --repo|-r)
            shift
            [[ $# -gt 0 ]] || die "--repo requires a value"
            REPO_FILTER="$1"
            [[ -n "$REPO_FILTER" ]] || die "--repo requires a non-empty value"
            shift
            ;;
        --repo=*)
            REPO_FILTER="${1#*=}"
            [[ -n "$REPO_FILTER" ]] || die "--repo requires a non-empty value"
            shift
            ;;
        --sort-date|--date-sort)
            SORT_MODE="date"
            shift
            ;;
        --)
            shift
            QUERY_ARGS+=("$@")
            break
            ;;
        --*)
            echo "Unknown option: $1" >&2
            usage >&2
            exit 1
            ;;
        *)
            QUERY_ARGS+=("$1")
            shift
            ;;
    esac
done

if [[ "$LIST_MODE" -eq 1 && ${#QUERY_ARGS[@]} -gt 0 ]]; then
    die "--list does not take search terms"
fi

if [[ "$LIST_MODE" -eq 0 && ${#QUERY_ARGS[@]} -eq 0 ]]; then
    if [[ "$DO_UPDATE" -eq 0 || -n "$REPO_FILTER" || "$SORT_MODE" == "date" ]]; then
        LIST_MODE=1
    fi
fi

if [[ "$DO_UPDATE" -eq 1 ]]; then
    command -v jq >/dev/null 2>&1 || die "--update requires jq (install with: brew install jq)"
    "$SCRIPT_DIR/session2md.sh"
fi

INITIAL_QUERY=""
if [[ "$LIST_MODE" -eq 1 ]]; then
    INITIAL_QUERY=""
elif [[ ${#QUERY_ARGS[@]} -gt 0 ]]; then
    INITIAL_QUERY="${QUERY_ARGS[*]}"
elif [[ "$DO_UPDATE" -eq 1 ]]; then
    exit 0
else
    usage
    exit 1
fi

# -- Run search + fzf ----------------------------------------------------

check_dependencies

if ! ensure_index; then
    exit 1
fi

SORT_STATE=$(mktemp "${TMPDIR:-/tmp}/sg-sort.XXXXX")
printf '%s\n' "$SORT_MODE" > "$SORT_STATE"

export SG_SESSION_DIR="$SESSION_DIR"
export SG_AWK_FMT="$AWK_FMT"
export SG_FTS_DB="$FTS_DB"
export SG_REPO_FILTER="$REPO_FILTER"
export SG_SORT_STATE="$SORT_STATE"

# Get initial results (all sessions or pre-filtered)
initial=$(bash "$HELPER" "$INITIAL_QUERY")

if [[ -z "$initial" ]]; then
    if [[ -n "$INITIAL_QUERY" && -n "$REPO_FILTER" ]]; then
        echo "No sessions found for query '$INITIAL_QUERY' with repo filter '$REPO_FILTER'."
        echo "Tip: refresh the index with: sg --update"
    elif [[ -n "$INITIAL_QUERY" ]]; then
        echo "No sessions found for query: $INITIAL_QUERY"
        echo "Tip: try --repo <repo> to filter by project, or refresh with: sg --update"
    elif [[ -n "$REPO_FILTER" ]]; then
        echo "No sessions found for repo filter: $REPO_FILTER"
        echo "Tip: refresh the index with: sg --update"
    else
        echo "No indexed sessions found."
        echo "Run: sg --update"
    fi
    exit 1
fi

FZF_HEADER="Type to search session content (Enter=open, Alt-d=toggle date sort, Esc=cancel) | score = relative relevance (1-100, 100=best)"
if [[ -n "$REPO_FILTER" ]]; then
    FZF_HEADER="Repo filter: $REPO_FILTER | $FZF_HEADER"
fi

# fzf with live content search: typing re-runs ranked retrieval via helper
selected=$(echo "$initial" | fzf \
    --ansi \
    --disabled \
    --query "$INITIAL_QUERY" \
    --bind "change:reload(bash '$HELPER' {q})" \
    --bind "alt-d:execute-silent(bash '$HELPER' --toggle-sort)+reload(bash '$HELPER' {q})" \
    --delimiter=$'\t' \
    --with-nth=7 \
    --preview="head -50 {6}" \
    --preview-window=right:50%:wrap \
    --header="$FZF_HEADER")

[[ -z "$selected" ]] && exit 0

# -- Extract and resume --------------------------------------------------

session_id=$(echo "$selected" | cut -f1)
agent=$(echo "$selected" | cut -f2)
project_dir=$(echo "$selected" | cut -f3)

# claude --resume is project-scoped: it only finds sessions for the cwd's project
if [[ -n "$project_dir" && -d "$project_dir" ]]; then
    cd "$project_dir"
fi

if [[ "$agent" == "claude" ]]; then
    command -v claude >/dev/null 2>&1 || die "claude CLI not found in PATH"
    cleanup
    trap - EXIT INT TERM
    exec claude --resume "$session_id"
else
    command -v codex >/dev/null 2>&1 || die "codex CLI not found in PATH"
    cleanup
    trap - EXIT INT TERM
    exec codex resume "$session_id"
fi
