#!/usr/bin/env bash
set -euo pipefail

# sg - search Claude Code & Codex sessions, pick one with fzf, resume it
#
# Usage:
#   sg                         Browse all sessions, type to search content
#   sg <search terms>         Search sessions and pick one to resume
#   sg --list                 Browse all sessions, type to search content
#   sg --update [search terms] Re-index sessions before searching

SESSION_DIR="$HOME/.cache/agent-grep/sessions"
# Resolve symlinks so SCRIPT_DIR points to the repo, not the symlink location
SELF="$0"
[[ -L "$SELF" ]] && SELF="$(readlink "$SELF")"
SCRIPT_DIR="$(cd "$(dirname "$SELF")" && pwd)"

# -- Search helper -------------------------------------------------------
#
# Written to a temp file so fzf's change:reload can call it.
# Uses rg for content search + gawk for fast frontmatter formatting.
# gawk is required (macOS /usr/bin/awk lacks ENDFILE): brew install gawk

AWK_FMT="$SCRIPT_DIR/.sg_fmt.awk"

usage() {
    cat <<'EOF'
sg - Search and resume Claude Code and Codex sessions.

Usage:
  sg
  sg <search terms>
  sg --list
  sg --update [search terms]
  sg --help

What it does:
  - Reads a local index of session transcripts in ~/.cache/agent-grep/sessions
  - Opens an interactive picker for searching and previewing sessions
  - Resumes the selected session with claude --resume or codex resume

Notes:
  - Running sg with no arguments opens browse mode (same as --list)
  - If no index exists, sg can prompt to run indexing for you

Examples:
  sg "billing timeout"
  sg --list
  sg --update
  sg --update "auth bug"

Dependencies:
  rg, gawk, fzf (and jq for --update)
EOF
}

die() {
    echo "sg: $*" >&2
    exit 1
}

check_dependencies() {
    local missing=()
    local cmd
    for cmd in rg gawk fzf; do
        command -v "$cmd" >/dev/null 2>&1 || missing+=("$cmd")
    done

    if [[ ${#missing[@]} -gt 0 ]]; then
        die "missing dependencies: ${missing[*]} (install with: brew install ripgrep gawk fzf)"
    fi
}

ensure_index() {
    if compgen -G "$SESSION_DIR/*.md" > /dev/null; then
        return 0
    fi

    echo "No indexed sessions found."

    # Prompt only when attached to a TTY; otherwise keep the current non-interactive behavior.
    if [[ ! -t 0 || ! -t 1 ]]; then
        echo "Run: sg --update"
        return 1
    fi

    printf "Run session indexing now? [Y/n] "
    local answer
    if ! IFS= read -r answer; then
        answer="n"
    fi

    case "$answer" in
        ""|[Yy]|[Yy][Ee][Ss])
            command -v jq >/dev/null 2>&1 || die "indexing requires jq (install with: brew install jq)"
            "$SCRIPT_DIR/session2md.sh"
            ;;
        *)
            echo "Run: sg --update"
            return 1
            ;;
    esac

    if ! compgen -G "$SESSION_DIR/*.md" > /dev/null; then
        echo "No sessions were indexed."
        echo "Run: sg --update --full"
        return 1
    fi
}

[[ -f "$AWK_FMT" ]] || die "formatter not found: $AWK_FMT"

HELPER=$(mktemp "${TMPDIR:-/tmp}/sg-helper.XXXXX")
cleanup() {
    rm -f "$HELPER"
}
trap cleanup EXIT INT TERM

cat > "$HELPER" << HELPEREOF
#!/usr/bin/env bash
QUERY="\$1"
if [[ -z "\$QUERY" ]]; then
    gawk -f "$AWK_FMT" "$SESSION_DIR"/*.md 2>/dev/null
else
    matches=\$(rg -l --no-messages -i -- "\$QUERY" "$SESSION_DIR"/*.md)
    if [[ -n "\$matches" ]]; then
        echo "\$matches" | xargs gawk -f "$AWK_FMT" 2>/dev/null
    fi
fi
HELPEREOF
chmod +x "$HELPER"

# -- Handle flags --------------------------------------------------------

DO_UPDATE=0
LIST_MODE=0
QUERY_ARGS=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        --help|-h)
            usage
            exit 0
            ;;
        --update)
            DO_UPDATE=1
            shift
            ;;
        --list)
            LIST_MODE=1
            shift
            ;;
        --)
            shift
            QUERY_ARGS+=("$@")
            break
            ;;
        --*)
            echo "Unknown option: $1" >&2
            usage >&2
            exit 1
            ;;
        *)
            QUERY_ARGS+=("$1")
            shift
            ;;
    esac
done

if [[ "$LIST_MODE" -eq 1 && ${#QUERY_ARGS[@]} -gt 0 ]]; then
    die "--list does not take search terms"
fi

if [[ "$LIST_MODE" -eq 0 && "$DO_UPDATE" -eq 0 && ${#QUERY_ARGS[@]} -eq 0 ]]; then
    LIST_MODE=1
fi

if [[ "$DO_UPDATE" -eq 1 ]]; then
    command -v jq >/dev/null 2>&1 || die "--update requires jq (install with: brew install jq)"
    "$SCRIPT_DIR/session2md.sh"
fi

INITIAL_QUERY=""
if [[ "$LIST_MODE" -eq 1 ]]; then
    INITIAL_QUERY=""
elif [[ ${#QUERY_ARGS[@]} -gt 0 ]]; then
    INITIAL_QUERY="${QUERY_ARGS[*]}"
elif [[ "$DO_UPDATE" -eq 1 ]]; then
    exit 0
else
    usage
    exit 1
fi

# -- Run search + fzf ----------------------------------------------------

check_dependencies

if ! ensure_index; then
    exit 1
fi

# Get initial results (all sessions or pre-filtered)
initial=$(bash "$HELPER" "$INITIAL_QUERY")

if [[ -z "$initial" ]]; then
    if [[ -n "$INITIAL_QUERY" ]]; then
        echo "No sessions found for: $INITIAL_QUERY"
        echo "Tip: refresh the index with: sg --update"
    else
        echo "No indexed sessions found."
        echo "Run: sg --update"
    fi
    exit 1
fi

# fzf with live content search: typing re-runs rg across session files
selected=$(echo "$initial" | fzf \
    --disabled \
    --query "$INITIAL_QUERY" \
    --bind "change:reload:bash '$HELPER' {q}" \
    --delimiter=$'\t' \
    --with-nth=4 \
    --preview="head -50 '$SESSION_DIR'/{2}-{1}.md" \
    --preview-window=right:50%:wrap \
    --header="Type to search session content (Enter=open, Esc=cancel)")

[[ -z "$selected" ]] && exit 0

# -- Extract and resume --------------------------------------------------

session_id=$(echo "$selected" | cut -f1)
agent=$(echo "$selected" | cut -f2)
project_dir=$(echo "$selected" | cut -f3)

# claude --resume is project-scoped: it only finds sessions for the cwd's project
if [[ -n "$project_dir" && -d "$project_dir" ]]; then
    cd "$project_dir"
fi

if [[ "$agent" == "claude" ]]; then
    command -v claude >/dev/null 2>&1 || die "claude CLI not found in PATH"
    cleanup
    trap - EXIT INT TERM
    exec claude --resume "$session_id"
else
    command -v codex >/dev/null 2>&1 || die "codex CLI not found in PATH"
    cleanup
    trap - EXIT INT TERM
    exec codex resume "$session_id"
fi
