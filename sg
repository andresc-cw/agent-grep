#!/usr/bin/env bash
set -euo pipefail

# sg — search Claude Code & Codex sessions, pick one with fzf, resume it
#
# Usage:
#   sg <search terms>         Search sessions and pick one to resume
#   sg --list                 Browse all sessions, type to search content
#   sg --update [search terms] Re-index sessions before searching

SESSION_DIR="$HOME/.cache/agent-grep/sessions"
# Resolve symlinks so SCRIPT_DIR points to the repo, not the symlink location
SELF="$0"
[[ -L "$SELF" ]] && SELF="$(readlink "$SELF")"
SCRIPT_DIR="$(cd "$(dirname "$SELF")" && pwd)"

# ── Search helper ───────────────────────────────────────────────────────
#
# Written to a temp file so fzf's change:reload can call it.
# Uses rg for content search + gawk for fast frontmatter formatting.
# gawk is required (macOS /usr/bin/awk lacks ENDFILE): brew install gawk

AWK_FMT="$SCRIPT_DIR/.sg_fmt.awk"

usage() {
    cat <<EOF
Usage: sg <search terms>
       sg --list
       sg --update [search terms]
       sg --help
EOF
}

die() {
    echo "sg: $*" >&2
    exit 1
}

check_dependencies() {
    local missing=()
    local cmd
    for cmd in rg gawk fzf; do
        command -v "$cmd" >/dev/null 2>&1 || missing+=("$cmd")
    done

    if [[ ${#missing[@]} -gt 0 ]]; then
        die "missing dependencies: ${missing[*]} (install with: brew install ripgrep gawk fzf)"
    fi
}

[[ -f "$AWK_FMT" ]] || die "formatter not found: $AWK_FMT"

HELPER=$(mktemp "${TMPDIR:-/tmp}/sg-helper.XXXXX")
cleanup() {
    rm -f "$HELPER"
}
trap cleanup EXIT INT TERM

cat > "$HELPER" << HELPEREOF
#!/usr/bin/env bash
QUERY="\$1"
if [[ -z "\$QUERY" ]]; then
    gawk -f "$AWK_FMT" "$SESSION_DIR"/*.md 2>/dev/null
else
    matches=\$(rg -l --no-messages -i -- "\$QUERY" "$SESSION_DIR"/*.md)
    if [[ -n "\$matches" ]]; then
        echo "\$matches" | xargs gawk -f "$AWK_FMT" 2>/dev/null
    fi
fi
HELPEREOF
chmod +x "$HELPER"

# ── Handle flags ────────────────────────────────────────────────────────

DO_UPDATE=0
LIST_MODE=0
QUERY_ARGS=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        --help|-h)
            usage
            exit 0
            ;;
        --update)
            DO_UPDATE=1
            shift
            ;;
        --list)
            LIST_MODE=1
            shift
            ;;
        --)
            shift
            QUERY_ARGS+=("$@")
            break
            ;;
        --*)
            echo "Unknown option: $1" >&2
            usage >&2
            exit 1
            ;;
        *)
            QUERY_ARGS+=("$1")
            shift
            ;;
    esac
done

if [[ "$LIST_MODE" -eq 1 && ${#QUERY_ARGS[@]} -gt 0 ]]; then
    die "--list does not take search terms"
fi

if [[ "$DO_UPDATE" -eq 1 ]]; then
    command -v jq >/dev/null 2>&1 || die "--update requires jq (install with: brew install jq)"
    "$SCRIPT_DIR/session2md.sh"
fi

INITIAL_QUERY=""
if [[ "$LIST_MODE" -eq 1 ]]; then
    INITIAL_QUERY=""
elif [[ ${#QUERY_ARGS[@]} -gt 0 ]]; then
    INITIAL_QUERY="${QUERY_ARGS[*]}"
elif [[ "$DO_UPDATE" -eq 1 ]]; then
    exit 0
else
    usage
    exit 1
fi

# ── Run search + fzf ───────────────────────────────────────────────────

check_dependencies

if ! compgen -G "$SESSION_DIR/*.md" > /dev/null; then
    echo "No indexed sessions found."
    echo "Run: sg --update"
    exit 1
fi

# Get initial results (all sessions or pre-filtered)
initial=$(bash "$HELPER" "$INITIAL_QUERY")

if [[ -z "$initial" ]]; then
    if [[ -n "$INITIAL_QUERY" ]]; then
        echo "No sessions found for: $INITIAL_QUERY"
        echo "Tip: refresh the index with: sg --update"
    else
        echo "No indexed sessions found."
        echo "Run: sg --update"
    fi
    exit 1
fi

# fzf with live content search: typing re-runs rg across session files
selected=$(echo "$initial" | fzf \
    --disabled \
    --query "$INITIAL_QUERY" \
    --bind "change:reload:bash '$HELPER' {q}" \
    --delimiter=$'\t' \
    --with-nth=4 \
    --preview="head -50 '$SESSION_DIR'/{2}-{1}.md" \
    --preview-window=right:50%:wrap \
    --header="Type to search session content (Enter=open, Esc=cancel)")

[[ -z "$selected" ]] && exit 0

# ── Extract and resume ──────────────────────────────────────────────────

session_id=$(echo "$selected" | cut -f1)
agent=$(echo "$selected" | cut -f2)
project_dir=$(echo "$selected" | cut -f3)

# claude --resume is project-scoped: it only finds sessions for the cwd's project
if [[ -n "$project_dir" && -d "$project_dir" ]]; then
    cd "$project_dir"
fi

if [[ "$agent" == "claude" ]]; then
    command -v claude >/dev/null 2>&1 || die "claude CLI not found in PATH"
    cleanup
    trap - EXIT INT TERM
    exec claude --resume "$session_id"
else
    command -v codex >/dev/null 2>&1 || die "codex CLI not found in PATH"
    cleanup
    trap - EXIT INT TERM
    exec codex --resume "$session_id"
fi
